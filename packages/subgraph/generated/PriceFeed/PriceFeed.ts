// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class LastGoodPriceUpdated extends ethereum.Event {
  get params(): LastGoodPriceUpdated__Params {
    return new LastGoodPriceUpdated__Params(this);
  }
}

export class LastGoodPriceUpdated__Params {
  _event: LastGoodPriceUpdated;

  constructor(event: LastGoodPriceUpdated) {
    this._event = event;
  }

  get _lastGoodPrice(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class PriceFeedStatusChanged extends ethereum.Event {
  get params(): PriceFeedStatusChanged__Params {
    return new PriceFeedStatusChanged__Params(this);
  }
}

export class PriceFeedStatusChanged__Params {
  _event: PriceFeedStatusChanged;

  constructor(event: PriceFeedStatusChanged) {
    this._event = event;
  }

  get newStatus(): i32 {
    return this._event.parameters[0].value.toI32();
  }
}

export class PriceFeed extends ethereum.SmartContract {
  static bind(address: Address): PriceFeed {
    return new PriceFeed("PriceFeed", address);
  }

  DECIMAL_PRECISION(): BigInt {
    let result = super.call(
      "DECIMAL_PRECISION",
      "DECIMAL_PRECISION():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_DECIMAL_PRECISION(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "DECIMAL_PRECISION",
      "DECIMAL_PRECISION():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  ETHUSD_TELLOR_REQ_ID(): BigInt {
    let result = super.call(
      "ETHUSD_TELLOR_REQ_ID",
      "ETHUSD_TELLOR_REQ_ID():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_ETHUSD_TELLOR_REQ_ID(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "ETHUSD_TELLOR_REQ_ID",
      "ETHUSD_TELLOR_REQ_ID():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND(): BigInt {
    let result = super.call(
      "MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND",
      "MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND",
      "MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES(): BigInt {
    let result = super.call(
      "MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES",
      "MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES",
      "MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  NAME(): string {
    let result = super.call("NAME", "NAME():(string)", []);

    return result[0].toString();
  }

  try_NAME(): ethereum.CallResult<string> {
    let result = super.tryCall("NAME", "NAME():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  TARGET_DIGITS(): BigInt {
    let result = super.call("TARGET_DIGITS", "TARGET_DIGITS():(uint256)", []);

    return result[0].toBigInt();
  }

  try_TARGET_DIGITS(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "TARGET_DIGITS",
      "TARGET_DIGITS():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  TELLOR_DIGITS(): BigInt {
    let result = super.call("TELLOR_DIGITS", "TELLOR_DIGITS():(uint256)", []);

    return result[0].toBigInt();
  }

  try_TELLOR_DIGITS(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "TELLOR_DIGITS",
      "TELLOR_DIGITS():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  TIMEOUT(): BigInt {
    let result = super.call("TIMEOUT", "TIMEOUT():(uint256)", []);

    return result[0].toBigInt();
  }

  try_TIMEOUT(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("TIMEOUT", "TIMEOUT():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  fetchPrice(): BigInt {
    let result = super.call("fetchPrice", "fetchPrice():(uint256)", []);

    return result[0].toBigInt();
  }

  try_fetchPrice(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("fetchPrice", "fetchPrice():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isOwner(): boolean {
    let result = super.call("isOwner", "isOwner():(bool)", []);

    return result[0].toBoolean();
  }

  try_isOwner(): ethereum.CallResult<boolean> {
    let result = super.tryCall("isOwner", "isOwner():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  lastGoodPrice(): BigInt {
    let result = super.call("lastGoodPrice", "lastGoodPrice():(uint256)", []);

    return result[0].toBigInt();
  }

  try_lastGoodPrice(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lastGoodPrice",
      "lastGoodPrice():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  priceAggregator(): Address {
    let result = super.call(
      "priceAggregator",
      "priceAggregator():(address)",
      [],
    );

    return result[0].toAddress();
  }

  try_priceAggregator(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "priceAggregator",
      "priceAggregator():(address)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  status(): i32 {
    let result = super.call("status", "status():(uint8)", []);

    return result[0].toI32();
  }

  try_status(): ethereum.CallResult<i32> {
    let result = super.tryCall("status", "status():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  tellorCaller(): Address {
    let result = super.call("tellorCaller", "tellorCaller():(address)", []);

    return result[0].toAddress();
  }

  try_tellorCaller(): ethereum.CallResult<Address> {
    let result = super.tryCall("tellorCaller", "tellorCaller():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class FetchPriceCall extends ethereum.Call {
  get inputs(): FetchPriceCall__Inputs {
    return new FetchPriceCall__Inputs(this);
  }

  get outputs(): FetchPriceCall__Outputs {
    return new FetchPriceCall__Outputs(this);
  }
}

export class FetchPriceCall__Inputs {
  _call: FetchPriceCall;

  constructor(call: FetchPriceCall) {
    this._call = call;
  }
}

export class FetchPriceCall__Outputs {
  _call: FetchPriceCall;

  constructor(call: FetchPriceCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SetAddressesCall extends ethereum.Call {
  get inputs(): SetAddressesCall__Inputs {
    return new SetAddressesCall__Inputs(this);
  }

  get outputs(): SetAddressesCall__Outputs {
    return new SetAddressesCall__Outputs(this);
  }
}

export class SetAddressesCall__Inputs {
  _call: SetAddressesCall;

  constructor(call: SetAddressesCall) {
    this._call = call;
  }

  get _priceAggregatorAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _tellorCallerAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class SetAddressesCall__Outputs {
  _call: SetAddressesCall;

  constructor(call: SetAddressesCall) {
    this._call = call;
  }
}
